<!DOCTYPE html>
<html>

<head>
  <title>WebGL - Rasterizer 2.0 Example</title>
  <style>
    * {
      margin: 0px;
    }
  </style>
</head>

<body>

  <canvas id="canv"></canvas>

  <script src="./vertexShader.js"></script>
  <script src="./fragmentShader.js"></script>

  <script>


    let canvas = document.querySelector("#canv")
    canvas.width = 640
    canvas.height = 640
    let gl = canvas.getContext("webgl");

    //Create the matrices we will use

    let projectionMatrix = new Float32Array(16);
    projectionMatrix[0] = 1.0           // X axis scaling
    projectionMatrix[5] = 1.0           // Y axis scaling
    projectionMatrix[10] = 0
    projectionMatrix[11] = 1.0
    projectionMatrix[15] = 0.0

    let modelViewMatrix = new Float32Array(16);
    modelViewMatrix[0] = 1.0
    modelViewMatrix[5] = 1.0
    modelViewMatrix[10] = 1.0
    modelViewMatrix[15] = 1.0
    modelViewMatrix[14] = 5;           // pushes object away from camera on Z axis          

    let positions = //The positions of the points of the triangle 
      [
        0.0, 0.0, 0.0,
        -1.0, -2.0, 0,
        1.0, -2.0, 0,
        0.0, -1.5, 0
        // -1, -1, -0,


        // 1.0, 1.0, -1,  // square facing away
        // -1.0, 1.0, -1,
        // 1.0, -1.0, -1,
        // -1, -1, -1,
      ];

    let normals =
      [
        0, 0, 1.,
        0, 0, 1.,
        0, 0, 1.,
        0, 0, 1.,
        // 0, 0, -1.,


        // 0, 0, 1., // square facing away
        // 0, 0, 1.,
        // 0, 0, 1.,
        // 0, 0, 1.,
      ]

    let uvs = [
      0.5, 1.0,
      0.0, 0.0,
      1.0, 0.0,
      0.5, 0.5
      // 1., 1.,


      // 0, 0, // square facing away
      // 1., 0,
      // 0, 1.,
      // 1., 1.,
    ]


    let shader = gl.createProgram();                                               //Create a program that we are going to use on the GPU
    gl.attachShader(shader, loadShader(gl, gl.VERTEX_SHADER, vertexShader));       //Assign the vertex shader code to a memory slot on the GPU
    gl.attachShader(shader, loadShader(gl, gl.FRAGMENT_SHADER, fragmentShader));   //Assign the vertex shader code to a memory slot on the GPU
    gl.linkProgram(shader);                                                        //Do the compiling and linking on the GPU
    if (!gl.getProgramParameter(shader, gl.LINK_STATUS)) { throw new Error(gl.getError()); }    //Do some error checking
    gl.useProgram(shader);                                                         //Tell the GPU that this is the program to use


    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());                              //Create a new buffer on the GPU and make it an array buffer
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);     //Put the positions into this new buffer

    // per-frame information

    let vertexPosition = gl.getAttribLocation(shader, "aPosition")                                     //Create a new variable called position that is the location attribute
    gl.vertexAttribPointer(vertexPosition, 3, gl.FLOAT, false, 0, 0);                                 //Create a vertex attribute that says they will be vec3s
    gl.enableVertexAttribArray(vertexPosition);                             //Enable the vertex attribute

    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());                              //Create a new buffer on the GPU and make it an array buffer
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);     //Put the positions into this new buffer

    let vertexNormal = gl.getAttribLocation(shader, "aNormal")                                     //Create a new variable called position that is the location attribute
    gl.vertexAttribPointer(vertexNormal, 3, gl.FLOAT, false, 0, 0);                                 //Create a vertex attribute that says they will be vec3s
    gl.enableVertexAttribArray(vertexNormal);                             //Enable the vertex attribute


    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());                              //Create a new buffer on the GPU and make it an array buffer
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);     //Put the positions into this new buffer

    let vertexUV = gl.getAttribLocation(shader, "aUV")                                     //Create a new variable called position that is the location attribute
    gl.vertexAttribPointer(vertexUV, 2, gl.FLOAT, false, 0, 0);                                 //Create a vertex attribute that says they will be vec3s
    gl.enableVertexAttribArray(vertexUV);                             //Enable the vertex attribute



    gl.uniformMatrix4fv(gl.getUniformLocation(shader, "uProjectionMatrix"), false, projectionMatrix);  //Create a uniform on the GPU called projectionMatrix

    //Our draw 
    // Each line is a triangle
    let positionIndices = [
      0, 1, 3, 
      0, 2, 3,
      // 4, 5, 6,
      // 5, 6, 7,
    ];


    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());                        //Create a new array buffer for indices
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(positionIndices), gl.STATIC_DRAW)  //Bind the index data to the new buffer

    //Function to compile the shaders

    function loadShader(gl, type, source) {
      let shader = gl.createShader(type);   //Allocate memory for the type of shader
      gl.shaderSource(shader, source);      //Assign the code as a string
      gl.compileShader(shader);             //Tell the GPU to compile the shader
      let compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS)
      let compilationLog = gl.getShaderInfoLog(shader)
      console.log(compiled, compilationLog)
      return shader;
    }

    let temp = 0
    let direction = 1;
    let maxX = 3.5;
    let minX = -3.5;
  
    function render() {
      temp += .01

      let x = direction * maxX * Math.sin(temp); // X movement
      let y = 0.1 * Math.pow(x, 2) - 2; // Y movement for pendulum shaped movement
      if (x >= maxX || x <= minX) {
        direction *= -1;
      }
      
      let scoopAngle = Math.sin(temp) * Math.PI / 4; // make triangle make a scooping motion and tilt

      let scaleX = Math.max(.75, 1 - Math.abs(x) / 5); // Scale down as x reaches extremities
      let cosA = Math.cos(scoopAngle);
      let sinA = Math.sin(scoopAngle);

      // Apply fixed rotation to keep the top vertex upright
      let rotationMatrix = [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        x, y, 5, 1
      ];
      rotationMatrix[1] = sinA; // X rotation?

      rotationMatrix[0] = cosA * scaleX; // Apply rotation and scaling on X-axis

      modelViewMatrix.set(rotationMatrix); //update the model matrix to be the post rotation matrix

      gl.uniformMatrix4fv(gl.getUniformLocation(shader, "uModelViewMatrix"), false, modelViewMatrix);    //Create a uniform on the GPU called modelViewMatrix
      gl.uniform1f(gl.getUniformLocation(shader, "uTime"), temp)

      gl.clearColor(0, 0, 0, 1.)
      gl.clearDepth(1.0)
      gl.enable(gl.DEPTH_TEST)
      gl.depthFunc(gl.LEQUAL)
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0)      //Draw N vertices as distinct triangles

    }

    setInterval(render, 10)

  </script>
</body>

</html>